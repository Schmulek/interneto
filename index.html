<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottie Animation</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        #lottie-animation, .second-animation-container {
            width: 100vw; 
            height: 100vh; 
            position: absolute;
            top: 0;
            left: 0;
            background-color: #f0f0f0; /* For visibility */
        }

        #draggable {
            width: 20px; /* Smaller size */
            height: 20px; /* Smaller size */
            background-color: blue;
            position: absolute;
            cursor: pointer;
            z-index: 1001;
        }

        #dropzone {
            width: 50px;
            height: 50px;
            border: 0px dashed rgb(145, 42, 42);
            position: absolute;
            top: 23%; /* Center vertically */
            left: 47%; /* Center horizontally */
            transform: translate(-50%, -50%); /* Adjust for center */
            z-index: 1000;

}
        #lottie-animation, .second-animation-container {
            width: 100vw; /* Adjust to your desired width */
            height: 100vh; /* Adjust to your desired height */
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    

    <img id="draggable" src="orzech.jpg" alt="Draggable Image">

    <div id="lottie-animation"></div>
    <div id="second-animation" style="display: none;"></div> <!-- New div for second animation -->
    <div id="dropzone"></div>

    <!-- Lottie Animation Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.7.8/lottie.min.js"></script> 
    <script>

    // Your Lottie animation container
    const container = document.getElementById('lottie-animation');

    // Initialize the first Lottie animation
    const initialAnimation = lottie.loadAnimation({
        container: container,
        renderer: 'svg',
        loop: true,
        autoplay: false, // Start playing immediately
        path: 'szupek.json' // Path to the initial animation file
    });

    // Create a container for the second animation and apply consistent styling
    const secondAnimationContainer = document.createElement('div');
    secondAnimationContainer.className = 'second-animation-container';
    secondAnimationContainer.style.display = 'none'; // Initially hidden
    container.parentNode.insertBefore(secondAnimationContainer, container.nextSibling);




// Initialize the second Lottie animation with consistent size settings
    const secondAnimation = lottie.loadAnimation({
        container: secondAnimationContainer,
        renderer: 'svg',
        loop: true,
        autoplay: false,
        path: 'drugaczesc.json' // Path to the second animation file
    });



    // Function to switch animations
    function switchAnimation(callback) {
    container.style.display = 'none'; // Hide the first animation
    secondAnimationContainer.style.display = 'block'; // Show the second animation container
    secondAnimation.play(); // Start playing the second animation

    if (callback && typeof callback === 'function') {
        setTimeout(callback, 0); // Execute callback after the current call stack clears
    }
}
// Updated function to handle both mouse and touch movement
function updateAnimationFrame(event) {
    let clientX, clientY;

    if(event.type === 'touchmove') {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    } else {
        clientX = event.clientX;
        clientY = event.clientY;
    }

    const bounds = container.getBoundingClientRect();
    const x = clientX - bounds.left;
    const y = clientY - bounds.top;
    const centerX = bounds.width / 2;
    const centerY = bounds.height / 2;
    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
    const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
    const frame = (distance / maxDistance) * 22 + 17;
    initialAnimation.goToAndStop(frame, true);
}

// Add touchmove event listener for animation frame update
document.addEventListener('touchmove', updateAnimationFrame);

// Add mousemove event listener
document.addEventListener('mousemove', updateAnimationFrame);

function isInsideDropZone(element, dropzone) {
    const elementRect = element.getBoundingClientRect();
    const dropzoneRect = dropzone.getBoundingClientRect();

    // Calculate the center of the draggable element
    const elementCenterX = elementRect.left + elementRect.width / 2;
    const elementCenterY = elementRect.top + elementRect.height / 2;

    // Check if the center of the draggable element is inside the dropzone
    return (
        elementCenterX >= dropzoneRect.left &&
        elementCenterX <= dropzoneRect.right &&
        elementCenterY >= dropzoneRect.top &&
        elementCenterY <= dropzoneRect.bottom
    );
}



// Function to play the new Lottie animation after drag and drop
function playNewAnimation() {
    initialAnimation.destroy(); // Destroy the initial animation
    lottie.loadAnimation({
        container: container,
        renderer: 'svg',
        loop: true,
        autoplay: true,
        path: 'drugaczesc.json' // Path to the new animation file
    });
}

// Draggable element logic
const draggable = document.getElementById('draggable');

// Use the image's natural width and height as its dimensions
let draggableWidth = draggable.naturalWidth;
let draggableHeight = draggable.naturalHeight;

// Existing mousedown event listener
draggable.addEventListener('mousedown', startDrag);

// New touchstart event listener
draggable.addEventListener('touchstart', startDrag);

function startDrag(event) {
    event.preventDefault();

    let shiftX, shiftY;

    if(event.type === 'touchstart') {
        shiftX = event.touches[0].clientX - draggable.getBoundingClientRect().left;
        shiftY = event.touches[0].clientY - draggable.getBoundingClientRect().top;
    } else { // mousedown
        shiftX = event.clientX - draggable.getBoundingClientRect().left;
        shiftY = event.clientY - draggable.getBoundingClientRect().top;
    }

    function moveAt(pageX, pageY) {
        draggable.style.left = pageX - shiftX + 'px';
        draggable.style.top = pageY - shiftY + 'px';
    }

    function onMouseMove(event) {
        moveAt(event.pageX, event.pageY);
    }

    function onTouchMove(event) {
        moveAt(event.touches[0].pageX, event.touches[0].pageY);
    }

    if(event.type === 'touchstart') {
        document.addEventListener('touchmove', onTouchMove);
    } else {
        document.addEventListener('mousemove', onMouseMove);
    }

    function endDrag(event) {
    // Remove event listeners
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('touchmove', onTouchMove);

    draggable.onmouseup = null;
    draggable.ontouchend = null;

    // Check if the draggable is inside the dropzone
    if (isInsideDropZone(draggable, document.getElementById('dropzone'))) {
        switchAnimation(function() {
            draggable.style.display = 'none'; // Hide the draggable element
        });
    }
    }

    

    draggable.onmouseup = endDrag;
    draggable.ontouchend = endDrag;
}

draggable.ondragstart = function() {
    return false;
};





    </script>
</body>
</html>
